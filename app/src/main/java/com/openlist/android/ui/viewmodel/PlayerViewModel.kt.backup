package com.alist.android.ui.viewmodel

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.alist.android.data.model.FileInfo
import com.alist.android.data.preferences.PreferencesRepository
import com.alist.android.data.preferences.PreferencesRepositoryImpl
import com.alist.android.data.network.NetworkModule
import com.alist.android.data.database.DatabaseModule
import com.alist.android.player.core.ExoPlayerManager
import com.alist.android.player.core.ExoPlayerManager.PlaybackState
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

class PlayerViewModel : ViewModel() {

    // 播放器管理器
    private val exoPlayerManager by lazy {
        ExoPlayerManager(android.app.Application())
    }

    // 数据仓库
    private val preferencesRepository: PreferencesRepository by lazy {
        PreferencesRepositoryImpl(NetworkModule.provideDataStore(android.app.Application()))
    }

    // 当前播放文件
    private val _currentFile = MutableStateFlow<FileInfo?>(null)
    val currentFile: StateFlow<FileInfo?> = _currentFile.asStateFlow()

    // 播放列表
    private val _playlist = MutableStateFlow<List<FileInfo>>(emptyList())
    val playlist: StateFlow<List<FileInfo>> = _playlist.asStateFlow()

    private val _currentPlaylistIndex = MutableStateFlow(0)
    val currentPlaylistIndex: StateFlow<Int> = _currentPlaylistIndex.asStateFlow()

    // 播放器状态
    private val _playbackState = MutableStateFlow(PlaybackState.IDLE)
    val playbackState: StateFlow<PlaybackState> = _playbackState.asStateFlow()

    private val _currentTime = MutableStateFlow(0L)
    val currentTime: StateFlow<Long> = _currentTime.asStateFlow()

    private val _duration = MutableStateFlow(0L)
    val duration: StateFlow<Long> = _duration.asStateFlow()

    private val _isPlaying = MutableStateFlow(false)
    val isPlaying: StateFlow<Boolean> = _isPlaying.asStateFlow()

    private val _bufferedPercentage = MutableStateFlow(0)
    val bufferedPercentage: StateFlow<Int> = _bufferedPercentage.asStateFlow()

    // 音轨控制
    private val _audioTracks = MutableStateFlow<List<ExoPlayerManager.AudioTrackInfo>>(emptyList())
    val audioTracks: StateFlow<List<ExoPlayerManager.AudioTrackInfo>> = _audioTracks.asStateFlow()

    private val _selectedAudioTrack = MutableStateFlow<ExoPlayerManager.AudioTrackInfo?>(null)
    val selectedAudioTrack: StateFlow<ExoPlayerManager.AudioTrackInfo?> = _selectedAudioTrack.asStateFlow()

    // 播放速度
    private val _playbackSpeed = MutableStateFlow(1.0f)
    val playbackSpeed: StateFlow<Float> = _playbackSpeed.asStateFlow()

    // 播放进度更新
    private var progressUpdateJob: kotlinx.coroutines.Job? = null

    init {
        observePlayerStates()
        startProgressUpdate()
        startProgressAutoSave()
    }

    private fun observePlayerStates() {
        // 观察播放器状态变化
        viewModelScope.launch {
            // 这里应该添加状态观察逻辑
        }
    }

    private fun startProgressUpdate() {
        progressUpdateJob = viewModelScope.launch {
            while (isActive) {
                if (exoPlayerManager.isPlaying()) {
                    _currentTime.value = exoPlayerManager.getCurrentPosition()
                    _duration.value = exoPlayerManager.getDuration()
                    _bufferedPercentage.value = calculateBufferedPercentage()
                }
                delay(1000) // 每秒更新一次
            }
        }
    }

    private fun calculateBufferedPercentage(): Int {
        val duration = exoPlayerManager.getDuration()
        val currentPosition = exoPlayerManager.getCurrentPosition()

        if (duration <= 0) return 0

        // 简单的缓冲百分比计算
        val bufferedDuration = exoPlayerManager.getDuration() - currentPosition
        return ((bufferedDuration.toFloat() / duration.toFloat()) * 100).toInt()
    }

    fun playFile(file: FileInfo, playlist: List<FileInfo> = listOf(file)) {
        viewModelScope.launch {
            _currentFile.value = file
            _playlist.value = playlist
            _currentPlaylistIndex.value = playlist.indexOf(file)

            // 获取文件播放链接
            val token = preferencesRepository.getAuthToken()
            token.collect { authToken ->
                authToken?.let { token ->
                    try {
                        val result = fileRepository.getFileLink(token, file.path)
                        result.collect { linkResult ->
                            linkResult.onSuccess { linkData ->
                                // 准备播放器
                                val playUrl = linkData.raw_url ?: linkData.url
                                exoPlayerManager.preparePlayer(playUrl)
                                exoPlayerManager.play()

                                // 保存播放历史
                                savePlayHistory(file, playUrl)

                                // 更新播放状态
                                updatePlayerStates()
                            }.onFailure { exception ->
                                // 处理错误
                                _playbackState.value = PlaybackState.ERROR
                            }
                        }
                    } catch (e: Exception) {
                        _playbackState.value = PlaybackState.ERROR
                    }
                }
            }
        }
    }

    fun play() {
        exoPlayerManager.play()
        _isPlaying.value = true
    }

    fun pause() {
        exoPlayerManager.pause()
        _isPlaying.value = false
    }

    fun togglePlayPause() {
        if (exoPlayerManager.isPlaying()) {
            pause()
        } else {
            play()
        }
    }

    fun stop() {
        exoPlayerManager.stop()
        _isPlaying.value = false
        _currentTime.value = 0L
        _playbackState.value = PlaybackState.IDLE
    }

    fun seekTo(positionMs: Long) {
        exoPlayerManager.seekTo(positionMs)
        _currentTime.value = positionMs
    }

    fun setPlaybackSpeed(speed: Float) {
        exoPlayerManager.setPlaybackSpeed(speed)
        _playbackSpeed.value = speed
    }

    fun getAvailableAudioTracks() {
        val tracks = exoPlayerManager.getAvailableAudioTracks()
        _audioTracks.value = tracks
    }

    fun selectAudioTrack(track: ExoPlayerManager.AudioTrackInfo) {
        exoPlayerManager.selectAudioTrack(track)
        _selectedAudioTrack.value = track
    }

    fun playNext() {
        val playlist = _playlist.value
        val currentIndex = _currentPlaylistIndex.value

        if (currentIndex < playlist.size - 1) {
            val nextFile = playlist[currentIndex + 1]
            playFile(nextFile, playlist)
        }
    }

    fun playPrevious() {
        val playlist = _playlist.value
        val currentIndex = _currentPlaylistIndex.value

        if (currentIndex > 0) {
            val previousFile = playlist[currentIndex - 1]
            playFile(previousFile, playlist)
        }
    }

    fun setPlaylist(files: List<FileInfo>, startIndex: Int = 0) {
        _playlist.value = files
        if (files.isNotEmpty() && startIndex in files.indices) {
            playFile(files[startIndex], files)
        }
    }

    fun addToPlaylist(file: FileInfo) {
        val currentPlaylist = _playlist.value.toMutableList()
        currentPlaylist.add(file)
        _playlist.value = currentPlaylist
    }

    fun removeFromPlaylist(file: FileInfo) {
        val currentPlaylist = _playlist.value.toMutableList()
        currentPlaylist.remove(file)
        _playlist.value = currentPlaylist

        // 如果删除的是当前播放文件，播放下一个
        if (_currentFile.value == file) {
            playNext()
        }
    }

    private fun updatePlayerStates() {
        _playbackState.value = exoPlayerManager.playbackState.value
        _isPlaying.value = exoPlayerManager.isPlaying()
        _currentTime.value = exoPlayerManager.getCurrentPosition()
        _duration.value = exoPlayerManager.getDuration()
        _playbackSpeed.value = exoPlayerManager.playbackSpeed.value
        _audioTracks.value = exoPlayerManager.audioTracks.value
        _selectedAudioTrack.value = exoPlayerManager.selectedAudioTrack.value
    }

    private suspend fun savePlayHistory(file: FileInfo, playUrl: String) {
        try {
            val serverUrl = preferencesRepository.getServerUrl() ?: ""
            playHistoryRepository.savePlayHistory(
                filePath = file.path,
                fileName = file.name,
                fileSize = file.size,
                isVideo = isVideoFile(file.name),
                duration = exoPlayerManager.getDuration(),
                currentPosition = exoPlayerManager.getCurrentPosition(),
                serverUrl = serverUrl,
                thumbUrl = file.thumb
            )
        } catch (e: Exception) {
            // 忽略保存历史失败
        }
    }

    private fun isVideoFile(fileName: String): Boolean {
        val videoExtensions = listOf(".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm", ".m4v")
        return videoExtensions.any { fileName.endsWith(it, ignoreCase = true) }
    }

    fun isAudioFile(fileName: String): Boolean {
        val audioExtensions = listOf(".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a", ".wma")
        return audioExtensions.any { fileName.endsWith(it, ignoreCase = true) }
    }

    fun formatDuration(durationMs: Long): String {
        val hours = durationMs / (1000 * 60 * 60)
        val minutes = (durationMs % (1000 * 60 * 60)) / (1000 * 60)
        val seconds = (durationMs % (1000 * 60)) / 1000

        return when {
            hours > 0 -> String.format("%02d:%02d:%02d", hours, minutes, seconds)
            else -> String.format("%02d:%02d", minutes, seconds)
        }
    }

    // 定期保存播放进度
    private fun startProgressAutoSave() {
        viewModelScope.launch {
            while (isActive) {
                if (exoPlayerManager.isPlaying() && _currentFile.value != null) {
                    val currentPosition = exoPlayerManager.getCurrentPosition()
                    val duration = exoPlayerManager.getDuration()

                    // 每10秒保存一次播放进度
                    if (currentPosition > 0 && duration > 0) {
                        try {
                            playHistoryRepository.updatePlaybackProgress(
                                filePath = _currentFile.value!!.path,
                                currentPosition = currentPosition,
                                duration = duration
                            )
                        } catch (e: Exception) {
                            // 忽略保存失败
                        }
                    }
                }
                delay(10000) // 每10秒保存一次
            }
        }
    }

    override fun onCleared() {
        super.onCleared()
        progressUpdateJob?.cancel()
        exoPlayerManager.release()

        // 在销毁前保存最终播放进度
        viewModelScope.launch {
            if (_currentFile.value != null) {
                try {
                    val currentPosition = exoPlayerManager.getCurrentPosition()
                    val duration = exoPlayerManager.getDuration()

                    playHistoryRepository.updatePlaybackProgress(
                        filePath = _currentFile.value!!.path,
                        currentPosition = currentPosition,
                        duration = duration
                    )
                } catch (e: Exception) {
                    // 忽略保存失败
                }
            }
        }
    }
}